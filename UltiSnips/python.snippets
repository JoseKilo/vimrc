###########################################################################
#                             Python Snippets                             #
###########################################################################

############
#  COMMON  #
############

global !p

import os
import glob
from subprocess import Popen, PIPE


def get_output(cmd):
    """Get the output of a shell command.

    :cmd: the command to execute
    :return: the command output

    """
    output = Popen(
        cmd,
        stdout=PIPE,
        stderr=PIPE,
        shell=True
    ).stdout.read().strip()

    return output


def get_vcs_username(path, username=''):
    """Get the user information from a local DVCS or the global values instead.

    :path: the path of the python file from where it is called the snippet
    :username: the default username if not one is founded
    :return: the user information (name & email) set in the DVCS

    """

    vcs_cmds = {
        '.git': {
            'user'  : 'git config --get user.name',
            'email' : 'git config --get user.email'
        },
        '.hg': {
            'user'  : 'hg showconfig ui.username'
        },
        '.bzr': {
            'user'  : 'bzr whoami'
        }
    }

    repo_directory, current_directory = os.path.dirname(path), os.getcwd()
    os.chdir(repo_directory)

    vcs_at_dir = [i for i in glob.iglob('.??*') if i in vcs_cmds.keys()]

    # if there is a local repository check only that type, else check all
    vcs_to_check = vcs_at_dir if vcs_at_dir else vcs_cmds.keys()

    for i in vcs_to_check:
        user = get_output(vcs_cmds[i].get('user'))
        email = get_output(vcs_cmds[i].get('email', ''))
        if user:
            os.chdir(current_directory)
            username = '{0} <{1}>'.format(user, email) if email else user
            break

    return username

endglobal


##############
#  New File  #
##############

snippet script "Template for new script" !b
#!/usr/bin/env python
# -*- coding: utf8 -*-

"""
`!p snip.rv = fn`

${1}

"""

__author__ = "${2:`!p snip.rv = get_vcs_username(vim.eval("expand('%:p')"))`}"
__license__ = "${3:MIT}"
__date__ = "`date +%Y-%m-%d`"
__version__ = "0.1"

try:
    import sys
    import os
    ${4}
except ImportError:
    print('''
          An error found importing one module:
          
          {0}
          
          You need to install it
          
          Stopping...
          '''.format(str(sys.exc_info()[1])).replace(' ', '')
          )
    sys.exit(-2)


def main():
    """Main section."""
    ${5:pass}

if __name__ == '__main__':
    main()
endsnippet

###########################################################################
#                             Simple Script                               #
###########################################################################

snippet ss "Template for a new simple script" !b
#!/usr/bin/env python
# -*- coding: utf8 -*-

"""
${1}
"""

${2}
endsnippet

snippet dec "Python standard decorator" !b
from functools import wraps

def my_decorator(f):
    @wraps(f)
    def wrapper(*args, **kwds):
        print('Calling decorated function')
        return f(*args, **kwds)
    return wrapper
endsnippet

snippet set "Django settings" !b
from django.conf import settings
endsnippet

snippet log "Import logging" !b
import logging
endsnippet

snippet logger "logger declaration" !b
logger = logging.getLogger('')
endsnippet

snippet pp "print statement" !b
print('C$1')
endsnippet

snippet ee "print to stderr" !b
print('C$1', file=sys.stderr)
endsnippet

snippet ll "logger call" !b
logger.info('C$1')
endsnippet

snippet ff "log to file" !b
with open("out.log", "a+") as ff:
    ff.write("C1 {}\n".format(42))
endsnippet

snippet injector "injector class" !b
class Injector:

    def __init__(self, **kwargs):
        self._objects = kwargs

    async def get(self, name):
        if name not in self._objects:
            builder = getattr(self, "make_{}".format(name))
            dependencies = set(inspect.signature(builder).parameters)
            kwargs = {}
            for dependency in dependencies:
                kwargs[dependency] = await self.get(dependency)

            if asyncio.iscoroutinefunction(builder):
                result = await builder(**kwargs)
            else:
                result = builder(**kwargs)

            self._objects[name] = result

        return self._objects[name]
endsnippet

snippet getattribute "getattribute" !b
def __getattribute__(self, name):
	return object.__getattribute__(self, name)
endsnippet

snippet bound "bind method" !b
setattr(obj, name, types.MethodType(func, obj))
endsnippet

snippet "" "docstring" !b
"""
${1}
"""
endsnippet

snippet sphinx "sphinx docstring" !b
"""
${1}

:param name: The name to use.
:type name: str.
:returns: int -- the return code.
:raises: AttributeError, KeyError

:param name:
	The name to use.

:param kwargs:
	Keyword arguments to pass to \`name\`

:returns:
	int -- the return code.

:raises:
	AttributeError, KeyError

"""
endsnippet

snippet googly "googly docstring" !b
"""
${1}

Args:
	param1 (int): The first parameter.
	param2 (:obj:`str`, optional): The second parameter. Defaults to None.
		Second line of description should be indented.
	*args: Variable length argument list.
	**kwargs: Arbitrary keyword arguments.

Returns:
	bool: True if successful, False otherwise.

	The ``Returns`` section may span multiple lines and paragraphs.
	Following lines should be indented to match the first line.

Raises:
	AttributeError: The ``Raises`` section is a list of all exceptions
		that are relevant to the interface.
	ValueError: If \`param2\` is equal to \`param1\`.
"""
endsnippet

snippet __getattribute__ "__getattribute__ Template" !b
def __getattribute__(self, name):
    import types
    xxx = object.__getattribute__(self, name)
    if isinstance(xxx, types.MethodType):
        def yyy(*args, **kwargs):
            print('C1', name)
            return xxx(*args, **kwargs)
        return yyy
    return xxx
endsnippet

snippet while "while" !b
while True:
    ${1:${VISUAL:pass}}
endsnippet

snippet param "Pytest's parametrize" !b
@pytest.mark.parametrize("$1,$2", (
	("$1", "$2"),
))
endsnippet

snippet caplog "Pytest's caplog" !b
with caplog.at_level(logging.${2:INFO}):
    ${1:${VISUAL:pass}}

assert [record.message for record in caplog.records] == []
endsnippet

snippet djangotest "Django test case" !b
from django.core.urlresolvers import reverse
from django.test import TestCase


class ${1}Test(TestCase):

	def test_${2}(self):
		"""
		${3}
		"""
		url = reverse('${4}')

		response = self.client.get(url)

		self.assertEqual(response, '')
endsnippet

snippet main "Python script with main method" !b
"""
2 3
4 5 -1

5
8
"""
import sys


def main():
	for line in sys.stdin.readlines():
		line = line.strip()
		print sum(map(int, line.split()))


if __name__ == '__main__':
	import helpers
	helpers.test_module_doc(__doc__, main)
	main()
endsnippet

snippet main2 "Python script with main method and utility to read stdin" !b
from __future__ import print_function

import sys


def line(cast=None, split=None):
    line = sys.stdin.readline()
	line = line.strip()
    if isinstance(split, str):
        line = line.split(split)
        if cast is not None:
            line = list(map(cast, line))
    elif cast is not None:
        line = cast(line)
    return line


def process_line(case, things):
    result = 42
    print('Case #{}: {}'.format(case, result))


def main():
    cases = line(int)
    for i in range(cases):
        N = line(int)
        things = line(int, ' ')
        assert len(things) == N
        process_line(i + 1, things)


if __name__ == '__main__':
    main()
endsnippet


snippet branchandbound "Branch and Bound schema" !b
class State(object):

    def __init__(self):
        pass

    def is_possible(self):
        return True

    def is_solution(self):
        return False

    def score(self, k):
        return 0

    def children(self, k):
        return []


class BranchAndBound(object):

	def __init__(self):
        self.optimum = 0
        self.state = None

    def store(self, state, optimum):
        self.state = state
        self.optimum = optimum

    def solution(self):
        if self.state is not None and self.state.is_solution():
            return self.state.cost
        else:
            return None

    def run(self, state):
        self.branch_and_bound(state, 0)

    def branch_and_bound(self, state, k):
        children = state.children(k)
        while children:
            state, k = children.pop()
            score = state.score(k)
            if state.is_possible(k) and score < self.optimum:
                if state.is_solution():
                    self.store(state, score)
                else:
                    self.branch_and_bound(state, k + 1)


runner = BranchAndBound()
state = State()
runner.run(state)
endsnippet

snippet memoize "memoize decorator" !b
def memoize(f):
    cache = {}

    def inner(*args):
        try:
            return cache[args]
        except KeyError:
            pass

        ret = f(*args)
        cache[args] = ret
        return ret

    return inner
endsnippet

snippet xtry "Try/Except" !b
try:
	${1:${VISUAL}}
except ${2:Exception}:
	pass
endsnippet

snippet raises "Pytest raises" !b
with pytest.raises(${1:Exception}) as exc:
	${2:${VISUAL}}
endsnippet
